\chapter{IMPLEMENTASI}

% \section{Implementasi Perangkat Lunak}
\section{Implementasi Model Klasifikasi}
Model klasifikasi diimplementasikan dalam bahasa Python menggunakan pustaka TensorFlow. Pustaka-pustaka yang dibutuhkan di-\mintinline{python}{import} pada Gambar~\ref{listing:har-import}.

\begin{figure}[h]
\begin{minted}[linenos=true]{python}
import tensorflow as tf
import tensorflow.contrib.slim as slim
import data
\end{minted}
\caption{\textit{Import} pustaka yang dibutuhkan model klasifikasi}
\label{listing:har-import}
\end{figure}


Model klasifikasi didefiniskan sebagai kelas \mintinline{python}{HARConvLSTM}. Gambar~\ref{listing:har-HARConvLSTM-constructor} menunjukkan \textit{constructor} dari kelas \mintinline{python}{HARConvLSTM}.

\begin{figure}[h]
    \inputminted[firstline=14,firstnumber=14,lastline=31,fontsize=\scriptsize]{python}{../har/har.py}
    \caption{\textit{Constructor} kelas HARConvLSTM}
    \label{listing:har-HARConvLSTM-constructor}
\end{figure}

Pada \textit{constructor} tersebut didefinikan beberapa atribut dari kelas \mintinline{python}{HARConvLSTM}. Atribut \mintinline{python}{self.features} adalah atribut untuk menyimpan data sensor yang akan diklasifikasi dan \mintinline{python}{self.target} adalah target aktivitas dari data tersebut. Atribut \mintinline{python}{self.features} menyimpan data sensor akselerometer dan giroskop sebagai matriks berukuran $1 \times 600$ dengan susunan

\begin{equation}
    \mintinline{python}{self.features} = [a_x^1, a_y^1, a_z^1, g_x^1, g_y^1, g_z^1,\dots, a_x^{100}, a_y^{100}, a_z^{100}, g_x^{100}, g_y^{100}, g_z^{100}]
\end{equation}

Graf komputasi dibuat sesuai dengan arsitektur yang telah disusun. Pada baris $23$ dan $24$, data masukan dikondisikan menjadi tensor \mintinline{python}{conv_input} seperti pada Persamaan~\ref{eq:tensor-masukan}. Perhitungan besar vektor data sensor dilakukan dengan metode \mintinline{python}{self.__preprocessing()}. Hasil dari metode tersebut diubah bentuknya dari $100 \times 8$ menjadi $100 \times 2 \times 4$ dengan instruksi pada baris $24$. Selanjutnya dua lapisan konvolusi didefinikan berurutan pada baris $25$ dan $26$ dengan fungsi \mintinline{python}{self.__conv_layer()}. Lapisan konvolusi pertama menerima input dari tensor \mintinline{python}{conv1_input} dan menghasilkan tensor \mintinline{python}{conv1}. Kemudian tensor \mintinline{python}{conv1} masuk ke lapisan konvolusi ke dua yang menghasilkan tensor \mintinline{python}{conv2}.

Dua lapisan LSTM dibuat dengan metode \mintinline{python}{self.__lstm_layer()} pada baris $28$. Lapisan LSTM ini menerima tensor \mintinline{python}{lstm_input} sebagai masukannya. Tensor \mintinline{python}{lstm_input} dibuat dengan mengubah bentuk tensor \mintinline{python}{conv2} dari $25 \times 2 \times 32$ menjadi $25 \times 64$ pada baris $27$. Setelah itu keluaran dari lapisan LSTM dimasukkan ke lapisan softmax pada baris $29$.

\begin{figure}[h]
    \inputminted[firstline=32,firstnumber=32,lastline=48,gobble=4]{python}{../har/har.py}
    \caption{Implementasi pengondisian data masukan}
    \label{listing:har-masukan}
\end{figure}

Metode \mintinline{python}{self.__preprocessing()} diimplementasikan pada Gambar~\ref{listing:har-masukan}. Metode ini digunakan untuk menghitung besar dari vektor akselerometer dan giroskop dan membentuk matriks akselerometer dan giroskop seperti pada Persamaan~\ref{eq:matriks-akselerometer} dan~\ref{eq:matriks-giroskop}. Besar vektor akselerometer dan giroskop dihitung dengan memanggi metode \mintinline{python}{self.__magnitude()} pada baris $38$ dan $39$. Adapun metode \mintinline{python}{self.__magnitude()} didefinisikan pada baris $43 - 48$.

Pembuatan lapisan konvolusi dengan metode \mintinline{python}{self.__conv_layer()} diimplementasikan pada Gambar~\ref{listing:har-konvolusi}. Metode tersebut menerima parameter \mintinline{python}{tensor_in} sebagai masukan lapisan konvolusi dan \mintinline{python}{filters} sebagai ukuran kernel yang digunakan. Bobot dan bias jaringan saraf diinisialisasi pada baris $52 - 53$ dengan metode \mintinline{python}{self.__weight_variable()} dan \mintinline{python}{self.__bias_variable()}. Kedua metode tersebut menginisialisasi nilai-nilai secara acak dari distribusi normal, seperti yang diimplementasikan pada baris $59 - 65$ dan $67 - 73$. Selanjutnya pada baris $55 - 57$ konvolusi dilakukan terhadap masukan dan bobot sesuai dengan Persamaan~\ref{eq:konvolusi-3d}, lalu hasilnya ditambahkan dengan bias dan dimasukkan pada fungsi aktivasi ReLU seperti pada Persamaan~\ref{eq:konvolusi-kernel}.

\begin{figure}[h]
    \inputminted[firstline=50,firstnumber=50,lastline=73,gobble=4]{python}{../har/har.py}
    \caption{Implementasi lapisan konvolusi}
    \label{listing:har-konvolusi}
\end{figure}

Gambar~\ref{listing:har-lstm} mengimplementasikan metode \mintinline{python}{self.__lstm_layer()} untuk pembuatan lapisan LSTM\@. Metode tersebut menerima parameter \mintinline{python}{tensor_in} sebagai masukan lapisan LSTM, \mintinline{python}{num_unit} sebagai jumlah sel LSTM pada masing-masing lapisan dan \mintinline{python}{num_layers} sebagai jumlah lapisan LSTM yang akan dibuat. Sesuai dengan paramter yang diberikan, sejumlah \mintinline{python}{num_layers} lapisan LSTM akan dibuat dengan \mintinline{python}{num_units} sel LSTM pada masing-masing lapisannya. Lapisan LSTM pertama menerima masukan dari \mintinline{python}{tensor_in}, sedangkan lapisan selanjutnya menerima masukan dari keluaran lapisan sebelumnya. Sesuai dengan arsitektur \textit{many-to-one}, pada baris $86$ dikembalikan keluaran pada langkah waktu terakhir dari lapisan LSTM terakhir.

\begin{figure}[h]
    \inputminted[firstline=75,firstnumber=75,lastline=86,gobble=4]{python}{../har/har.py}
    \caption{Implementasi lapisan LSTM}
    \label{listing:har-lstm}
\end{figure}

% \section{Implementasi Pelatihan}

% \begin{figure}[h]
%     \inputminted[firstline=89,firstnumber=89,lastline=104,gobble=4]{python}{../har/har.py}
%     \caption{Implementasi \textit{cross entropy} dan RMSProp}
%     \label{listing:har-cross-entropy-rmsprop}
% \end{figure}

% \begin{figure}[h]
%     \inputminted[firstline=147,firstnumber=147,lastline=176,gobble=4]{python}{../har/har.py}
%     \caption{Implementasi proses pelatihan}
%     \label{listing:har-pelatihan}
% \end{figure}

% \begin{figure}[h]
%     \inputminted[firstline=178,firstnumber=178,lastline=190,gobble=4]{python}{../har/har.py}
%     \caption{Implementasi pengujian model}
%     \label{listing:har-pengujian-model}
% \end{figure}


\section{Implementasi Pengambilan dan Pengondisian Data}
Data latih dan data uji dipersiapkan dengan fungsi \mintinline{python}{get()} yang diimplementasikan pada Gambar~\ref{listing:data-pengambilan-data-latih-uji}. Fungsi tersebut menerima parameter \mintinline{python}{filenames} sebagai daftar nama file dataset, \mintinline{python}{num_target} sebagai jumlah kelas aktivitas yang akan dikenali, \mintinline{python}{windows_size} sebagai lebar jendela, \mintinline{python}{overlap} sebagai aturan tumpang tindih jendela dan \mintinline{python}{divider} sebagai pembagi data latih dan uji.

\begin{figure}[h]
    \inputminted[firstline=5,firstnumber=5,lastline=22]{python}{../har/data.py}
    \caption{Implementasi pengambilan data latih dan data uji}
    \label{listing:data-pengambilan-data-latih-uji}
\end{figure}

Pada baris ke $6$, fungsi \mintinline{python}{load()} mengekstrak data sensor dan target aktivitas dari file serta mengaplikasikan \textit{sliding window} pada data tersebut. Lalu hasil \textit{sliding window} diacak dengan fungsi \mintinline{python}{shuffle()} pada baris $7$. Jika diberikan parameter \mintinline{python}{divider}, maka data dan target dibagi untuk data latih dan data uji dengan fungsi \mintinline{python}{divide()} pada baris $10 - 11$.

\begin{figure}[h]
    \inputminted[firstline=25,firstnumber=25,lastline=44]{python}{../har/data.py}
    \caption{Implementasi pengambilan data dari file}
    \label{listing:data-pengambilan-data-file}
\end{figure}

Implementasi fungsi \mintinline{python}{load()} dapat dilihat pada Gambar~\ref{listing:data-pengambilan-data-file}. Pada baris $30$ data dari seluruh \mintinline{python}{filename} diekstrak menghasilkan tuple \mintinline{python}{file} dengan anggota \mintinline{python}{data} dan \mintinline{python}{target}. Baris $36$ mengaplikasikan fungsi \textit{sliding\_window}, lalu data dan target dari seluruh \mintinline{python}{filename} digabungkan pada baris $37-42$.

Proses \textit{sliding window} diimplementasikan pada Gambar~\ref{listing:data-sliding-window}. Pada baris $51-56$ dilakukan iterasi pada seluruh \mintinline{python}{data} dan \mintinline{python}{target} untuk membuat jendela dengan ukuran \mintinline{python}{windows_size} dan dan aturan tumpang tindih \mintinline{python}{overlap}.

\begin{figure}[h]
    \inputminted[firstline=47,firstnumber=47,lastline=58]{python}{../har/data.py}
    \caption{Implementasi \textit{sliding windows}}
    \label{listing:data-sliding-window}
\end{figure}

Setelah diperoleh rangkaian jendela \mintinline{python}{data} dan \mintinline{python}{target} dari fungsi \mintinline{python}{load()}, rangkaian jendela tersebut diacak fungsi \mintinline{python}{shuffle()} yang diimplementasikan pada Gambar~\ref{listing:data-pengacakan-data}. Pada baris $62-63$, \mintinline{python}{data} dan \mintinline{python}{target} digabungkan agar urutan pasangan keduanya tetap konsisten setelah melalui proses pengacakan. Pengacakan dilakukan pada baris $64$, lalu \mintinline{python}{data} dan \mintinline{python}{target} dipisahkan kembali pada baris $66-67$.

\begin{figure}[h]
    \inputminted[firstline=61,firstnumber=61,lastline=69]{python}{../har/data.py}
    \caption{Implementasi pengacakan data}
    \label{listing:data-pengacakan-data}
\end{figure}

Pembagian data latih dan data uji dilakukan dengan fungsi \mintinline{python}{divide()} yang diimplementasikan pada Gambar~\ref{listing:data-pembagian-data-latih-uji}. Fungsi \mintinline{python}{divide()} menerima parameter \mintinline{python}{arr} sebagai data yang akan dibagi dan \mintinline{python}{divider} sebagai rasio pembagian data. Sejumlah $(divider \times 100) \%$ data dari \mintinline{python}{arr} dijadikan data latih dan sisanya dijadikan data uji.

\begin{figure}[h]
    \inputminted[firstline=72,firstnumber=72,lastline=76]{python}{../har/data.py}
    \caption{Implementasi pembagian data latih dan data uji}
    \label{listing:data-pembagian-data-latih-uji}
\end{figure}

\section{Implementasi Klasifikasi Pada Ponsel Cerdas}
Sistem diimplemantasikan pada ponsel cerdas dengan sistem operasi Android. Proses klasifikasi dimulai dengan pengambilan dan pengondisian data sensor akselerometer dan giroskop. Kedua sensor tersebut diinisialisasi oleh kelas \mintinline{java}{SensorReader} pada Gambar~\ref{listing:inisialisasi-sensor}. \textit{Constructor} \mintinline{java}{SensorReader()} menerima \mintinline{java}{List} berisi jenis sensor yang akan dibaca, lalu pada baris $28-30$ seluruhnya didaftarkan untuk pembacaan dengan fungsi \mintinline{java}{registerSensorIfAvailable()}.

\begin{figure}[h]
    \inputminted[firstline=14,firstnumber=14,lastline=32]{java}{../aktvtas/app/src/main/java/org/elins/aktvtas/sensor/SensorReader.java}
    \caption{Inisialisasi sensor}
    \label{listing:inisialisasi-sensor}
\end{figure}

Fungsi \mintinline{java}{registerSensorIfAvailable()} pada Gambar~\ref{listing:mendaftarkan-sensor} digunakan untuk mendaftarkan \textit{listener} pada masing-masing sensor dan mengatur \textit{sampling rate} menjadi 50 Hz. Sehingga setiap 20 milisekon, ketika bacaan baru dari sensor telah siap, fungsi \textit{callback} \mintinline{java}{onSensorDataReady()} akan dipanggil.

\begin{figure}[h]
    \inputminted[firstline=38,firstnumber=38,lastline=44,gobble=4]{java}{../aktvtas/app/src/main/java/org/elins/aktvtas/sensor/SensorReader.java}
    \caption{Mendaftarkan sensor}
    \label{listing:mendaftarkan-sensor}
\end{figure}

Data sensor disimpan dan dikelola dalam dua struktur data, yaitu \mintinline{java}{SensorData} dan \mintinline{java}{SensorDataSequence}. Struktur \mintinline{java}{SensorData} (Gambar~\ref{listing:sensor-data}) digunakan untuk menyimpan dan mengelola data satu sensor dalam satu waktu, sedangkan struktur \mintinline{java}{SensorDataSequence} (Gambar~\ref{listing:sensor-data-sequence}) digunakan untuk menyimpan dan mengelola jendela data dari seluruh sensor.

\begin{figure}[h]
    \inputminted[firstline=6,firstnumber=6,lastline=16]{java}{../aktvtas/app/src/main/java/org/elins/aktvtas/sensor/SensorData.java}
    \caption{Struktur SensorData}
    \label{listing:sensor-data}
\end{figure}

\begin{figure}[h]
    \inputminted[firstline=9,firstnumber=9,lastline=13]{java}{../aktvtas/app/src/main/java/org/elins/aktvtas/sensor/SensorDataSequence.java}
    \caption{Struktur SensorDataSequence}
    \label{listing:sensor-data-sequence}
\end{figure}

Pengambilan data sensor dilakukan dalam kelas \mintinline{java}{SensorService}. Kelas \mintinline{java}{SensorService} mengimplementasikan \textit{interface} \mintinline{java}{SensorReaderEvent} dari kelas \mintinline{java}{SensorReader}, sehingga setiap kali bacaan sensor baru tersedia, implementasi metode \mintinline{java}{onSensorDataReady()} pada kelas \mintinline{java}{SensorService} akan dipanggil (Gambar~\ref{listing:callback-sensor-ready}). Pada baris $47$, data sensor dibaca dan menghasilkan \mintinline{java}{List} berisi \mintinline{java}{SensorData} terbaru dari seluruh sensor. Kemudian data tersebut disusun menjadi \mintinline{java}{SensorDataSequence} pada baris $59-52$.

\begin{figure}[h]
    \inputminted[firstline=45,firstnumber=45,lastline=56,gobble=4]{java}{../aktvtas/app/src/main/java/org/elins/aktvtas/sensor/SensorService.java}
    \caption{Struktur SensorDataSequence}
    \label{listing:callback-sensor-ready}
\end{figure}

Pengenalan aktivitas manusia dilakukan secara \textit{real time} pada ponsel cerdas dengan kelas \mintinline{java}{PredictionService} yang memperluas kelas \mintinline{java}{SensorService}. Kelas \mintinline{java}{PredictionService} mengimplementasikan metode \mintinline{java}{onSensorDataReady()} seperti pada Gambar~\ref{listing:callback-sensor-ready-prediction}.

\begin{figure}[h]
    \inputminted[firstline=97,firstnumber=97,lastline=123,gobble=4]{java}{../aktvtas/app/src/main/java/org/elins/aktvtas/PredictionService.java}
    \caption{Struktur SensorDataSequence}
    \label{listing:callback-sensor-ready-prediction}
\end{figure}

Pada baris $99$, metode \mintinline{java}{super.onSensorDataReady()} dipanggil untuk menjalankan implementasi \mintinline{java}{onSensorDataReady()} pada kelas \mintinline{java}{SensorService}. Pemanggilan metode tersebut dilakukan untuk menyusun bacaan sensor menjadi struktur \mintinline{java}{SensorDataSequence}. Saat ukuran \mintinline{java}{SensorDataSequence} telah sesuai dengan ukuran jendela yang diinginkan, aktivitas diklasifikasikan dengan memanggil metode \mintinline{java}{classifier.classify(SensorDataSequence)} pada baris $104$.

Akurasi pengenalan dihitung pada baris $116-123$. Pengenalan yang tepat diketahui dengan membandingkan hasil klasifikasi dengan referensi. Pada baris $122$, tingkat akurasi pengenalan dihitung dengan persamaan

\begin{equation}
    accuracy = \frac{correctPrediction}{totalPrediction} \times 100
\end{equation}

Klasifikasi dengan metode \mintinline{java}{classify()} diimplementasikan pada Gambar~\ref{listing:klasifikasi-aktivitas}. Metode tersebut menerima parameter \mintinline{java}{SensorDataSequence} sebagai masukan dari model klasifikasi. Pada baris $35$, \mintinline{java}{SensorDataSequence} diratakan menjadi matriks satu dimensi dengan memanggil metode \mintinline{java}{sequence.flatten()}. Pada baris $44-46$, data dimasukkan ke model klasifikasi dengan \mintinline{java}{inferenceInterface.feed()}, klasifikasi dijalankan dengan \mintinline{java}{inferenceInterface.run()} dan keluaran diambil dengan \mintinline{java}{inferenceInterface.fetch()}. Objek \mintinline{java}{inferenceInterface} sendiri merupakan \textit{instance} dari kelas \mintinline{java}{TensorFlowInferenceInterface}. Hasil klasifikasi terbaik dicari dengan metode \mintinline{java}{findBestClassification()}.

\begin{figure}[h]
    \inputminted[firstline=34,firstnumber=34,lastline=56,gobble=4]{java}{../aktvtas/app/src/main/java/org/elins/aktvtas/human/HumanActivityClassifier.java}
    \caption{Pengklasifikasian Aktivitas Manusia}
    \label{listing:klasifikasi-aktivitas}
\end{figure}

\section{Implementasi Pengujian}
